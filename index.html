<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Zmanim Lookup</title>
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <style>
        /* General page layout and typography */
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f0f4f8;
    color: #333;
}

h1, h2 {
    color: #2c3e50;
    text-align: center;
}

form, #results, #chart-container, .zmanim-results-container {
    background-color: #ffffff;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
}

/* General input and button styling */
input, button, select {
    width: 100%;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-sizing: border-box;
}

button {
    background-color: #3498db;
    color: white;
    border: none;
    padding: 12px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    border-radius: 8px;
    transition: background-color 0.3s ease;
}

button:hover {
    background-color: #2980b9;
}

/* Styling for form elements */
.form-group {
    margin-bottom: 20px;
}

label {
    display: block;
    margin-bottom: 10px;
    font-weight: bold;
}

/* Zmanim Checkboxes */
#zmanim-select {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin-bottom: 20px;
}

.zman-checkbox {
    display: flex;
    align-items: center;
}

.zman-checkbox input {
    margin-right: 8px;
    width: auto;
}

/* City Input Section */
#cities-container {
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
}

.city-input {
    flex: 1;
}

/* Button group styling */
.select-buttons {
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
}

/* Today's Zmanim Button */
#zmanim-today-container {
    background-color: #ffffff;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
    margin-bottom: 30px;
    text-align: center;
}

#zmanim-today-location {
    width: auto;
    padding: 12px 30px;
    margin-top: 20px;
    background-color: #e74c3c;
    color: white;
    font-size: 16px;
    font-weight: bold;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

#zmanim-today-location:hover {
    background-color: #c0392b;
}

/* Results Display Styling */
.zmanim-results-container {
    margin-top: 30px;
    padding: 30px;
    background-color: #fdfdfd;
    border: 1px solid #ddd;
    border-radius: 12px;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
}

.zmanim-results-title {
    font-size: 22px;
    margin-bottom: 20px;
    color: #2c3e50;
    font-weight: bold;
}

.zmanim-item {
    display: flex;
    justify-content: space-between;
    padding: 15px;
    border-bottom: 1px solid #eee;
    border-radius: 8px;
    background-color: #f8f9fa;
    margin-bottom: 10px;
}

.zmanim-item:last-child {
    border-bottom: none;
}

.zmanim-item .zmanim-name {
    font-weight: bold;
    color: #3498db;
    font-size: 18px;
}

.zmanim-item .zmanim-time {
    color: #34495e;
    font-size: 16px;
    font-weight: bold;
}

.zmanim-item .zmanim-time::before {
    content: "⏰ ";
}

/* Chart Container */
#chart-container {
    height: 400px;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
}
    </style>
</head>
<body>
    <h1>Advanced Zmanim Lookup</h1>
    <div id="zmanim-today-container">
        <h2>Get Zmanim for Today</h2>
        <p>Click the button below to get the Zmanim for your current location today.</p>
        <button id="zmanim-today-location">Today's Zmanim</button>
    </div>
    
    <!-- Results container for Today's Zmanim -->
    <div id="zmanim-today-results" class="zmanim-results-container"></div>
    
    <!-- The rest of the Zmanim lookup form and chart area -->
    <form id="zmanim-form">
        <div id="map" style="height: 400px; margin-bottom: 20px;"></div>
        <div id="cities-container">
            <div class="city-input">
                <input type="text" placeholder="Enter city name" required>
                <button type="button" class="remove-city" style="display:none;">Remove</button>
            </div>
        </div>
        <button type="button" id="add-city">Add City</button>
        <div class="form-group">
            <label for="start-date">Start Date:</label>
            <input type="date" id="start-date" required>
        </div>
        <div class="form-group">
            <label for="end-date">End Date (Optional):</label>
            <input type="date" id="end-date">
        </div>
        <div class="form-group">
            <label>Select Zmanim:</label>
            <div class="select-buttons">
                <button type="button" id="select-all">Select All</button>
                <button type="button" id="deselect-all">Deselect All</button>
            </div>
            <div id="zmanim-select"></div>
        </div>
        <button type="submit">Get Zmanim</button>
    </form>
    
    <div id="results"></div>
    <div id="chart-container">
        <div id="zmanim-chart"></div>
    </div>

    <script>

        let chart; // Global variable to hold the chart instance
        const zmanim = [
            "chatzotNight", "alotHaShachar", "misheyakir", "misheyakirMachmir", "dawn", "sunrise", 
            "sofZmanShmaMGA19Point8", "sofZmanShmaMGA16Point1", "sofZmanShmaMGA", "sofZmanShma", 
            "sofZmanTfillaMGA19Point8", "sofZmanTfillaMGA16Point1", "sofZmanTfillaMGA", "sofZmanTfilla",
            "chatzot", "minchaGedola", "minchaGedolaMGA", "minchaKetana", "minchaKetanaMGA", 
            "plagHaMincha", "sunset", "beinHaShmashos", "dusk", "tzeit7083deg", "tzeit85deg", 
            "tzeit42min", "tzeit50min", "tzeit72min"
        ];

        const zmanimLabels = {
            "chatzotNight": "Chatzot Night",
            "alotHaShachar": "Alot HaShachar",
            "misheyakir": "Misheyakir",
            "misheyakirMachmir": "Misheyakir Machmir",
            "dawn": "Dawn",
            "sunrise": "Sunrise",
            "sofZmanShmaMGA19Point8": "Sof Zman Shma (MGA 19.8°)",
            "sofZmanShmaMGA16Point1": "Sof Zman Shma (MGA 16.1°)",
            "sofZmanShmaMGA": "Sof Zman Shma (MGA)",
            "sofZmanShma": "Sof Zman Shma",
            "sofZmanTfillaMGA19Point8": "Sof Zman Tfilla (MGA 19.8°)",
            "sofZmanTfillaMGA16Point1": "Sof Zman Tfilla (MGA 16.1°)",
            "sofZmanTfillaMGA": "Sof Zman Tfilla (MGA)",
            "sofZmanTfilla": "Sof Zman Tfilla",
            "chatzot": "Chatzot",
            "minchaGedola": "Mincha Gedola",
            "minchaGedolaMGA": "Mincha Gedola (MGA)",
            "minchaKetana": "Mincha Ketana",
            "minchaKetanaMGA": "Mincha Ketana (MGA)",
            "plagHaMincha": "Plag HaMincha",
            "sunset": "Sunset",
            "beinHaShmashos": "Bein HaShmashos",
            "dusk": "Dusk",
            "tzeit7083deg": "Tzeit 70.83°",
            "tzeit85deg": "Tzeit 85°",
            "tzeit42min": "Tzeit 42 min",
            "tzeit50min": "Tzeit 50 min",
            "tzeit72min": "Tzeit 72 min"
        };


        document.addEventListener("DOMContentLoaded", function() {
    console.log('Initializing map and form.');
    
    const map = L.map('map').setView([41.85003, -87.65005], 10); // Default to Chicago
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    let reverseGeocodedCity = ""; // Variable to store the reverse-geocoded city name

// Handle map click event
map.on('click', async function(e) {
    const lat = e.latlng.lat.toFixed(4);
    const lng = e.latlng.lng.toFixed(4);
    const cityInput = document.querySelector('#cities-container input');

    if (cityInput) {
        cityInput.value = `${lat}, ${lng}`;

        // Automatically fetch Zmanim data after updating the input
        await updateZmanimData(lat, lng);
    }
});
});

async function updateZmanimData(lat, lng) {
    try {
        // Fetch city name using reverse geocoding
        const cityName = await getCityFromLatLong(lat, lng);

        // Log the coordinates and the reverse-geocoded city name
        console.log(`Fetching Zmanim data for lat: ${lat}, lng: ${lng}, city: ${cityName}`);

        // Fetch Zmanim data
        const zmanimData = await fetchZmanimForLocation(lat, lng);

        // Construct the location label with lat/long and city name
        const locationLabel = `Location: ${lat}, ${lng} (${cityName})`;

        // Update the display with Zmanim data and chart
        displayResults([zmanimData], [locationLabel], zmanimData.date.start, zmanimData.date.end);
        const selectedZmanim = Array.from(document.querySelectorAll('input[name="zmanim"]:checked')).map(cb => cb.value);
        createChart([zmanimData], [locationLabel], zmanimData.date.start, zmanimData.date.end, selectedZmanim);
    } catch (error) {
        console.error("Error fetching Zmanim data:", error);
    }
}

async function fetchZmanimForLocation(lat, lng) {
    const today = new Date().toISOString().split('T')[0]; // Get today's date
    const params = new URLSearchParams({
        cfg: 'json',
        latitude: lat,
        longitude: lng,
        start: today,
        end: today,
        b: '18',
        M: 'on',
        m: '50'
    });

    const apiUrl = `https://www.hebcal.com/zmanim?${params}`;
    console.log(`Calling Hebcal API with lat/long: ${apiUrl}`);

    const response = await fetch(apiUrl);
    if (!response.ok) {
        const errorData = await response.json();
        console.error('API Error:', errorData);
        throw new Error('Failed to fetch Zmanim data');
    }

    const data = await response.json();
    console.log('Received Zmanim data:', data);
    
    // Properly format times if available
    data.times = Object.fromEntries(
        Object.entries(data.times).map(([zman, time]) => [zman, { [today]: time }])
    );
    
    return data;
}

async function getCityFromLatLong(lat, lng) {
    console.log(`Reverse geocoding for lat: ${lat}, lng: ${lng}`);

    const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=10&addressdetails=1`);
    const data = await response.json();

    if (data && data.address) {
        console.log(`Reverse geocoding result:`, data.address);
        return data.address.city || data.address.town || data.address.village || "Unknown Location";
    } else {
        console.warn(`No city found for lat: ${lat}, lng: ${lng}`);
        return "Unknown Location";
    }
}

function populateZmanimCheckboxes() {
    const container = document.getElementById('zmanim-select');
    zmanim.forEach(zman => {
        const checkbox = document.createElement('div');
        checkbox.className = 'zman-checkbox';
        checkbox.innerHTML = `
            <input type="checkbox" id="${zman}" name="zmanim" value="${zman}">
            <label for="${zman}">${zmanimLabels[zman]}</label>
        `;
        container.appendChild(checkbox);
    });
    console.log('Zmanim checkboxes populated.');
}

populateZmanimCheckboxes();

document.getElementById('select-all').addEventListener('click', () => {
    document.querySelectorAll('input[name="zmanim"]').forEach(cb => cb.checked = true);
    console.log('All Zmanim checkboxes selected.');
});

document.getElementById('deselect-all').addEventListener('click', () => {
    document.querySelectorAll('input[name="zmanim"]').forEach(cb => cb.checked = false);
    console.log('All Zmanim checkboxes deselected.');
});

document.getElementById('add-city').addEventListener('click', () => {
    const citiesContainer = document.getElementById('cities-container');
    const newCity = document.createElement('div');
    newCity.className = 'city-input';
    newCity.innerHTML = `
        <input type="text" placeholder="Enter city name" required>
        <button type="button" class="remove-city">Remove</button>
    `;
    citiesContainer.appendChild(newCity);
    console.log('New city input added.');

    newCity.querySelector('.remove-city').addEventListener('click', () => {
        citiesContainer.removeChild(newCity);
        console.log('City input removed.');
    });
});

document.getElementById('zmanim-form').addEventListener('submit', async (e) => {
    e.preventDefault(); // Prevent the form from resetting
    console.log('Form submitted, fetching Zmanim.');

    // Retrieve city inputs (which may include lat/long)
    const cityInputs = Array.from(document.querySelectorAll('#cities-container input')).map(input => input.value);
    const startDate = document.getElementById('start-date').value;
    const endDate = document.getElementById('end-date').value || startDate; // Use startDate if endDate is not provided
    const selectedZmanim = Array.from(document.querySelectorAll('input[name="zmanim"]:checked')).map(cb => cb.value);
    const resultsDiv = document.getElementById('results');

    console.log(`Fetching Zmanim for cities: ${cityInputs}, from ${startDate} to ${endDate}`);
    
    resultsDiv.innerHTML = '<p>Loading...</p>';

    try {
        // Fetch Zmanim data for each city/lat-long combination
        const zmanimData = await Promise.all(cityInputs.map(async (cityOrLatLong) => {
            // Check if the input is a lat/long pair or a city name
            if (cityOrLatLong.includes(',')) {
                const [lat, lng] = cityOrLatLong.split(',').map(coord => coord.trim());
                const cityName = await getCityFromLatLong(lat, lng); // Reverse-geocode the city name
                return {
                    zmanimData: await fetchZmanimForLocation(lat, lng), // Fetch Zmanim using lat/long
                    locationLabel: `${lat}, ${lng} (${cityName})` // Display both lat/long and city
                };
            } else {
                // Handle regular city name (for cities directly entered)
                const latLongData = await fetchLatLongForCity(cityOrLatLong); // Assume you have a function to get lat/long from city
                return {
                    zmanimData: await fetchZmanimForLocation(latLongData.lat, latLongData.lng),
                    locationLabel: `${latLongData.lat}, ${latLongData.lng} (${cityOrLatLong})` // Combine lat/long and city
                };
            }
        }));

        // Extract Zmanim data and location labels for display
        const zmanimArray = zmanimData.map(data => data.zmanimData);
        const locationLabels = zmanimData.map(data => data.locationLabel);

        console.log('Zmanim data fetched:', zmanimArray);

        // Display results and create chart
        displayResults(zmanimArray, locationLabels, startDate, endDate, selectedZmanim);
        createChart(zmanimArray, locationLabels, startDate, endDate, selectedZmanim);
    } catch (error) {
        resultsDiv.innerHTML = `<p>Error: ${error.message}</p>`;
        console.error('Error fetching Zmanim:', error);
    }
});

async function fetchLatLongForCity(city) {
    // You can implement this function using an API or a pre-defined map to get lat/long from a city name
    // For example:
    const response = await fetch(`https://nominatim.openstreetmap.org/search?city=${city}&format=json&limit=1`);
    const data = await response.json();
    if (data && data.length > 0) {
        return { lat: data[0].lat, lng: data[0].lon };
    }
    return { lat: 0, lng: 0 }; // Default if no result found
}

async function fetchZmanimForDateRange(cityOrLatLng, startDate, endDate, selectedZmanim) {
    let params;

    if (typeof cityOrLatLng === 'string' && cityOrLatLng.includes(',')) {
        // Treat as lat/long if a comma is present
        const [latitude, longitude] = cityOrLatLng.split(',').map(coord => coord.trim());
        params = new URLSearchParams({
            cfg: 'json',
            latitude: latitude,
            longitude: longitude,
            start: startDate,
            end: endDate,
            b: '18',
            M: 'on',
            m: '50'
        });
    } else {
        // Treat as city name
        params = new URLSearchParams({
            cfg: 'json',
            city: cityOrLatLng,
            start: startDate,
            end: endDate,
            b: '18',
            M: 'on',
            m: '50'
        });
    }

    const response = await fetch(`https://www.hebcal.com/zmanim?${params}`);
    const data = await response.json();

    // Debugging: Log the raw data returned from the API
    console.log('Raw Zmanim Data:', data);

    // Ensure the data structure is uniform, whether for single or multiple dates
    if (!data.times || Object.keys(data.times).length === 0) {
        return { times: {} }; // Return an empty times object if no data is found
    }

    if (startDate === endDate) {
        data.times = Object.fromEntries(
            Object.entries(data.times).map(([zman, time]) => [zman, { [startDate]: time }])
        );
    }

    return data;
}

function displayResults(zmanimData, cities, startDate, endDate) {
    const selectedZmanim = Array.from(document.querySelectorAll('input[name="zmanim"]:checked')).map(cb => cb.value);
    const resultsDiv = document.getElementById('results');
    
    if (!zmanimData || zmanimData.length === 0) {
        resultsDiv.innerHTML = '<p>No Zmanim data available.</p>';
        return;
    }

    if (!selectedZmanim || selectedZmanim.length === 0) {
        resultsDiv.innerHTML = '<p>No Zmanim selected.</p>';
        return;
    }

    let html = `<h2>Zmanim Comparison (${startDate || 'N/A'} to ${endDate || 'N/A'})</h2>`;

    cities.forEach((locationLabel, index) => {
        const cityData = zmanimData[index];
        html += `<h3>${locationLabel}</h3>`;  // Display lat, long, and city name

        if (cityData && cityData.times) {
            const times = cityData.times;
            const timeZone = cityData.location?.tzid || 'UTC'; // Default to UTC if time zone is not provided
            let cityHtml = '<ul>';
            selectedZmanim.forEach(zman => {
                if (times[zman]) {
                    Object.entries(times[zman]).forEach(([date, time]) => {
                        if (time) {
                            const zmanTime = new Date(time);
                            // Ensure time is valid
                            if (!isNaN(zmanTime.getTime())) {
                                const formattedTime = zmanTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', timeZone });
                                cityHtml += `<li>${formatZmanName(zman)} (${date}): ${formattedTime} (${timeZone})</li>`;
                            } else {
                                cityHtml += `<li>${formatZmanName(zman)} (${date}): Invalid Date</li>`;
                            }
                        }
                    });
                } else {
                    cityHtml += `<li>${formatZmanName(zman)}: No data available</li>`;
                }
            });
            cityHtml += '</ul>';
            html += cityHtml;
        } else {
            html += '<p>No data available for this location.</p>';
        }
    });

    resultsDiv.innerHTML = html;
}

function createChart(zmanimData, cities, startDate, endDate, selectedZmanim) {
    if (chart) {
        chart.destroy();  // Destroy the previous chart instance
    }

    const series = [];
    let minTime = Infinity;
    let maxTime = -Infinity;

    selectedZmanim.forEach(zman => {
        cities.forEach((locationLabel, cityIndex) => {
            const data = [];
            const cityData = zmanimData[cityIndex];
            const timeZone = cityData.location?.tzid || 'UTC';  // Use the time zone provided or default to UTC

            if (cityData.times[zman]) {
                Object.entries(cityData.times[zman]).forEach(([date, time]) => {
                    if (time) {
                        const parsedDate = new Date(date + 'T00:00:00'); // Parse the date part
                        const zmanTime = new Date(time); // Zman time as Date object

                        // Convert time to the appropriate time zone
                        const formattedTime = new Date(zmanTime.toLocaleString('en-US', {
                            timeZone: timeZone
                        }));

                        // Calculate the time in hours
                        const timeInHours = formattedTime.getHours() + formattedTime.getMinutes() / 60;
                        data.push([parsedDate.getTime(), timeInHours]);

                        // Update min and max times for y-axis range
                        if (timeInHours < minTime) minTime = timeInHours;
                        if (timeInHours > maxTime) maxTime = timeInHours;
                    }
                });
            }

            if (data.length > 0) {
                series.push({
                    name: `${formatZmanName(zman)} - ${locationLabel}`,  // Correctly label the chart with the city
                    data: data.sort((a, b) => a[0] - b[0]),
                    type: startDate === endDate ? 'scatter' : 'line', // Use scatter for single date
                    markers: {
                        size: 8,
                    },
                    stroke: {
                        width: startDate === endDate ? 0 : 2, // No line for single date
                    }
                });
            }
        });
    });

    const padding = 0.5;
    minTime = Math.max(minTime - padding, 0);
    maxTime = Math.min(maxTime + padding, 24);

    const options = {
        chart: {
            type: 'line',
            height: 400,
            toolbar: {
                show: true
            }
        },
        series: series,
        xaxis: {
            type: 'datetime',
            title: {
                text: 'Date'
            },
            labels: {
                format: 'yyyy-MM-dd'
            },
            tickAmount: series[0]?.data.length > 1 ? undefined : 1
        },
        yaxis: {
            title: {
                text: 'Time'
            },
            min: minTime,
            max: maxTime,
            labels: {
                formatter: function(value) {
                    const hours = Math.floor(value);
                    const minutes = Math.round((value - hours) * 60);
                    const ampm = hours >= 12 ? 'PM' : 'AM';
                    const formattedHours = hours % 12 || 12;
                    return `${formattedHours}:${minutes < 10 ? '0' : ''}${minutes} ${ampm}`;
                }
            },
            tickAmount: 12
        },
        stroke: {
            curve: 'smooth'
        },
        markers: {
            size: 6,
        },
        tooltip: {
            x: {
                format: 'yyyy-MM-dd'
            },
            y: {
                formatter: function(value) {
                    const hours = Math.floor(value);
                    const minutes = Math.round((value - hours) * 60);
                    const ampm = hours >= 12 ? 'PM' : 'AM';
                    const formattedHours = hours % 12 || 12;
                    return `${formattedHours}:${minutes < 10 ? '0' : ''}${minutes} ${ampm}`;
                }
            }
        },
        grid: {
            show: true,
            xaxis: {
                lines: {
                    show: true
                }
            },
            yaxis: {
                lines: {
                    show: true
                }
            }
        }
    };

    chart = new ApexCharts(document.querySelector("#zmanim-chart"), options);
    chart.render();
}


        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        document.getElementById('zmanim-today-location').addEventListener('click', async () => {
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(async (position) => {
            const lat = position.coords.latitude.toFixed(4);
            const lng = position.coords.longitude.toFixed(4);
            const today = new Date().toISOString().split('T')[0];

            console.log(`Fetching Zmanim for today's date (${today}) at current location: ${lat}, ${lng}`);
            try {
                const zmanimData = await fetchZmanimForLocation(lat, lng, today, today);
                const cityName = await getCityFromLatLong(lat, lng);
                const locationLabel = `${lat}, ${lng} (${cityName})`;

                // Display Zmanim in the new container
                displayZmanimResults(zmanimData, locationLabel, today);

                // Update the chart as well if needed
                const selectedZmanim = zmanim; // Use all Zmanim
                createChart([zmanimData], [locationLabel], today, today, selectedZmanim);
            } catch (error) {
                console.error("Error fetching Zmanim for current location:", error);
            }
        }, (error) => {
            console.error("Error getting current location:", error);
        });
    } else {
        console.warn("Geolocation is not supported by this browser.");
    }
});

function displayZmanimResults(zmanimData, locationLabel, date) {
    const resultsContainer = document.getElementById('zmanim-today-results');
    resultsContainer.innerHTML = ''; // Clear previous results

    // Create the title
    const title = document.createElement('div');
    title.className = 'zmanim-results-title';
    title.textContent = `Zmanim for ${locationLabel} on ${date}`;
    resultsContainer.appendChild(title);

    // Create the list of Zmanim items
    if (zmanimData && zmanimData.times) {
        Object.entries(zmanimData.times).forEach(([zman, timeObj]) => {
            const time = timeObj[date];
            if (time) {
                const zmanItem = document.createElement('div');
                zmanItem.className = 'zmanim-item';

                const zmanName = document.createElement('div');
                zmanName.className = 'zmanim-name';
                zmanName.textContent = formatZmanName(zman);

                const zmanTime = new Date(time); // Create a date object from the time
                const formattedTime = !isNaN(zmanTime.getTime()) 
                    ? zmanTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                    : "Invalid Date";

                const zmanTimeDiv = document.createElement('div');
                zmanTimeDiv.className = 'zmanim-time';
                zmanTimeDiv.textContent = formattedTime;

                zmanItem.appendChild(zmanName);
                zmanItem.appendChild(zmanTimeDiv);

                resultsContainer.appendChild(zmanItem);
            }
        });
    } else {
        resultsContainer.innerHTML = '<p>No Zmanim data available.</p>';
    }
}

function formatZmanName(zman) {
    return zman
        .replace(/([A-Z])/g, ' $1')
        .split(/(?=[A-Z])/)
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ')
        .trim();
}
    </script>
</body>
</html>
